/** @file
	Parser: executor part of request class.

	Copyright (c) 2001, 2002 ArtLebedev Group (http://www.artlebedev.com)
	Author: Alexandr Petrosian <paf@design.ru> (http://paf.design.ru)
*/

static const char* IDENT_EXECUTE_C="$Date: 2002/08/12 10:32:52 $";

#include "pa_opcode.h"
#include "pa_array.h" 
#include "pa_request.h"
#include "pa_vstring.h"
#include "pa_vhash.h"
#include "pa_vvoid.h"
#include "pa_vcode_frame.h"
#include "pa_vmethod_frame.h"
#include "pa_vobject.h"
#include "pa_vdouble.h"
#include "pa_vbool.h"
#include "pa_vtable.h"
#include "pa_vfile.h"
#include "pa_vimage.h"
#include "pa_wwrapper.h"

//#define DEBUG_EXECUTE
//#define DEBUG_STRING_APPENDS_VS_EXPANDS


#ifdef DEBUG_STRING_APPENDS_VS_EXPANDS
ulong wcontext_result_size=0;
#endif



#ifdef DEBUG_EXECUTE
char *opcode_name[]={
	// literals
	"VALUE",  "CURLY_CODE__STORE_PARAM",  "EXPR_CODE__STORE_PARAM",
	"NESTED_CODE",

	// actions
	"WITH_ROOT",	"WITH_SELF",	"WITH_READ",	"WITH_WRITE",
	"GET_CLASS",
	"CONSTRUCT_VALUE", "CONSTRUCT_EXPR", "CURLY_CODE__CONSTRUCT",
	"WRITE_VALUE",  "WRITE_EXPR_RESULT",  "STRING__WRITE",
	"GET_ELEMENT_OR_OPERATOR", "GET_ELEMENT",	"GET_ELEMENT__WRITE",
	"OBJECT_POOL",	"STRING_POOL",
	"STORE_PARAM",
	"PREPARE_TO_CONSTRUCT_OBJECT",	"PREPARE_TO_EXPRESSION", 
	"CALL", "CALL__WRITE",

	// expression ops: unary
	"NEG", "INV", "NOT", "DEF", "IN", "FEXISTS", "DEXISTS",
	// expression ops: binary
	"SUB", "ADD", "MUL", "DIV", "MOD", "INTDIV",
	"BIN_AND", "BIN_OR", "BIN_XOR",
	"LOG_AND", "LOG_OR", "LOG_XOR",
	"NUM_LT", "NUM_GT", "NUM_LE", "NUM_GE", "NUM_EQ", "NUM_NE",
	"STR_LT", "STR_GT", "STR_LE", "STR_GE", "STR_EQ", "STR_NE",
	"IS"
};

void va_debug_printf(Pool& pool, const char *fmt,va_list args) {
	char buf[MAX_STRING];
	vsnprintf(buf, MAX_STRING, fmt, args);
	SAPI::log(pool, "%s", buf);
}

void debug_printf(Pool& pool, const char *fmt, ...) {
    va_list args;
    va_start(args,fmt);
    va_debug_printf(pool,fmt,args);
    va_end(args);
}

void debug_dump(Pool& pool, int level, const Array& ops) {
	Array_iter i(ops);
	while(i.has_next()) {
		Operation op;
		op.cast=i.next();

		if(op.code==OP_VALUE || op.code==OP_STRING__WRITE) {
			Value *value=static_cast<Value *>(i.next());
			debug_printf(pool, 
				"%*s%s"
				" \"%s\" %s", 
				level*4, "", opcode_name[op.code],
				value->get_string()->cstr(), value->type());
			continue;
		}
		debug_printf(pool, "%*s%s", level*4, "", opcode_name[op.code]);

		switch(op.code) {
		case OP_CURLY_CODE__STORE_PARAM: 
		case OP_EXPR_CODE__STORE_PARAM:
		case OP_CURLY_CODE__CONSTRUCT:
		case OP_NESTED_CODE:
		case OP_OBJECT_POOL:  
		case OP_STRING_POOL:
		case OP_CALL:
			const Array *local_ops=reinterpret_cast<const Array *>(i.next());
			debug_dump(pool, level+1, *local_ops);
		}
	}
}
#endif

#define PUSH(value) stack.push(value)
#define POP() static_cast<Value *>(stack.pop())
#define POP_NAME() static_cast<Value *>(stack.pop())->as_string()
#define POP_CODE() static_cast<Array *>(stack.pop())

/**
	Helps preventing evaluation of junctions in outdated context

	To stop situations like this:
@code
	@main[]
	^method1[]
	^method2[]

	@method1[]
	$junction{
		some code
	}

	@method2[]
	^junction[]
@endcode

	All Junctions, generated by OP_CURLY_CODE__CONSTRUCT are registered here,
	and on scope exit got cleaned - there Junction::root becomes 0,
	which later in Request::process triggers exception
*/
class Auto_junction_cleaner {
public:
	Auto_junction_cleaner () : junctions(0) {}
	~Auto_junction_cleaner () {
		if(junctions) {
			Array_iter i(*junctions);
			while(i.has_next())
				static_cast<Junction *>(i.next())->change_context(0);
			// someday free junctions
		}
	}
	void register_junction(Pool& apool, Junction& ajunction) {
		if(!junctions)
			junctions=new(apool) Array(apool);
		if(junctions)
			*junctions+=&ajunction;
	}
private:
	Array  *junctions;
};

void Request::execute(const Array& ops) {
//	_asm int 3;
#ifdef DEBUG_EXECUTE
	debug_printf(pool(), "source----------------------------\n");
	debug_dump(pool(), 0, ops);
	debug_printf(pool(), "execution-------------------------\n");
#endif

	Auto_junction_cleaner junction_cleaner;
	const String *last_get_element_name=0;

	Array_iter i(ops);
	while(i.has_next()) {
		Operation op;
		op.cast=i.next();
#ifdef DEBUG_EXECUTE
		debug_printf(pool(), "%d:%s", stack.top_index()+1, opcode_name[op.code]);
#endif

		Value *value;
		Value *a; Value *b;
		Array *b_code;
		switch(op.code) {
		// param in next instruction
		case OP_VALUE:
			{
				value=static_cast<Value *>(i.next());
#ifdef DEBUG_EXECUTE
				debug_printf(pool(), " \"%s\" %s", value->get_string()->cstr(), value->type());
#endif
				PUSH(value);
				break;
			}
		case OP_GET_CLASS:
			{
				// maybe they do ^class:method[] call, remember the fact
				wcontext->set_somebody_entered_some_class();

				const String& name=POP_NAME();
				value=static_cast<Value *>(classes().get(name));
				if(!value) 
					throw Exception("parser.runtime",
						&name,
						"class is undefined"); 

				PUSH(value);
				break;
			}
			
		// OP_WITH
		case OP_WITH_ROOT:
			{
				PUSH(root);
				break;
			}
		case OP_WITH_SELF: 
			{
				PUSH(self);
				break;
			}
		case OP_WITH_READ: 
			{
				PUSH(rcontext);
				break;
			}
		case OP_WITH_WRITE: 
			{
				PUSH(wcontext);
				break;
			}
			
		// OTHER ACTIONS BUT WITHs
		case OP_CONSTRUCT_VALUE:
			{
				value=POP();
				const String& name=POP_NAME();
				Value *ncontext=POP();
				ncontext->put_element(name, value);
				break;
			}
		case OP_CONSTRUCT_EXPR:
			{
				// see OP_PREPARE_TO_EXPRESSION
				wcontext->set_in_expression(false);

				value=POP();
				const String& name=POP_NAME();
				Value *ncontext=POP();
				ncontext->put_element(name, value->as_expr_result());
				break;
			}
		case OP_CURLY_CODE__CONSTRUCT:
			{
				const Array *local_ops=reinterpret_cast<const Array *>(i.next());
#ifdef DEBUG_EXECUTE
				debug_printf(pool(), " (%d)\n", local_ops->size());
				debug_dump(pool(), 1, *local_ops);
#endif				
				Junction& j=*NEW Junction(pool(), 
					*self, 0, 0,
					root, 
					rcontext, 
					wcontext, 
					local_ops);
				junction_cleaner.register_junction(pool(), j);

				value=NEW VJunction(j);
				const String& name=POP_NAME();
				Value *ncontext=POP();
				ncontext->put_element(name, value);
				break;
			}
		case OP_NESTED_CODE:
			{
				Array *local_ops=static_cast<Array *>(i.next());
#ifdef DEBUG_EXECUTE
				debug_printf(pool(), " (%d)\n", local_ops->size());
				debug_dump(pool(), 1, *local_ops);
#endif				
				PUSH(local_ops);
				break;
			}
		case OP_WRITE_VALUE:
			{
				value=POP();
				write_assign_lang(*value, last_get_element_name);
				break;
			}
		case OP_WRITE_EXPR_RESULT:
			{
				value=POP();
				write_no_lang(*value->as_expr_result());

				// must be after write(result) and 
				// see OP_PREPARE_TO_EXPRESSION
				wcontext->set_in_expression(false);
				break;
			}
		case OP_STRING__WRITE:
			{
				VString *vstring=static_cast<VString *>(i.next());
#ifdef DEBUG_EXECUTE
				debug_printf(pool(), " \"%s\"", vstring->string().cstr());
#endif
				write_no_lang(vstring->string());
				break;
			}
			
		case OP_GET_ELEMENT_OR_OPERATOR:
			{
				// maybe they do ^object.method[] call, remember the fact
				wcontext->set_somebody_entered_some_object(true);

				//_asm int 3;
				value=get_element(last_get_element_name, true);
				PUSH(value);
				break;
			}
		case OP_GET_ELEMENT:
			{
				// maybe they do ^object.method[] call, remember the fact
				wcontext->set_somebody_entered_some_object(true);

				//_asm int 3;
				value=get_element(last_get_element_name, false);
				PUSH(value);
				break;
			}

		case OP_GET_ELEMENT__WRITE:
			{
				value=get_element(last_get_element_name/*not followed by call, not needed really*/, false);
				write_assign_lang(*value, last_get_element_name);
				break;
			}


		case OP_OBJECT_POOL:
			{
				const Array *local_ops=reinterpret_cast<const Array *>(i.next());
				
				PUSH(wcontext);
				PUSH((void *)flang);
				flang=String::UL_PASS_APPENDED;
				WWrapper local(pool(), 0 /*empty*/);
				wcontext=&local;

				execute(*local_ops);

				value=&wcontext->result().as_value();
				flang=static_cast<String::Untaint_lang>(reinterpret_cast<int>(POP()));
				wcontext=static_cast<WContext *>(POP());
				PUSH(value);
				break;
			}
			
		case OP_STRING_POOL:
			{
				const Array *local_ops=reinterpret_cast<const Array *>(i.next());

				PUSH(wcontext);
				WWrapper local(pool(), 0 /*empty*/);
				wcontext=&local;

				execute(*local_ops);

				// from "$a $b" part of expression taking only string value,
				// ignoring any other content of wcontext
				const String *string=wcontext->get_string();
				Value *value;
				if(string)
					value=NEW VString(*string);
				else
					NEW VVoid(pool());
				wcontext=static_cast<WContext *>(POP());
				PUSH(value);
				break;
			}

		// CALL
		case OP_STORE_PARAM:
			{
				value=POP();
				VMethodFrame *frame=static_cast<VMethodFrame *>(stack.top_value());
				// this op is executed from CALL local_ops only, so can not check method_frame_to_fill==0
				frame->store_param(value);
				break;
			}
		case OP_CURLY_CODE__STORE_PARAM:
		case OP_EXPR_CODE__STORE_PARAM:
			{
				// code
				const Array *local_ops=reinterpret_cast<const Array *>(i.next());
				VMethodFrame *frame=static_cast<VMethodFrame *>(stack.top_value());
#ifdef DEBUG_EXECUTE
				debug_printf(pool(), " (%d)\n", local_ops->size());
				debug_dump(pool(), 1, *local_ops);
#endif				
				// when they evaluate expression parameter,
				// the object expression result
				// does not need to be written into calling frame
				// it must go into any expressions using that parameter
				// hence, we zero junction.wcontext here, and later
				// in .process we would test that field 
				// in decision "which wwrapper to use"
				Junction& j=*NEW Junction(pool(), 
					*self, 0, 0,
					root, 
					rcontext, 
					op.code==OP_EXPR_CODE__STORE_PARAM?0:wcontext, 
					local_ops);
				
				value=NEW VJunction(j);

				// store param
				// this op is executed from CALL local_ops only, so can not check method_frame_to_fill==0
				frame->store_param(value);
				break;
			}

		case OP_PREPARE_TO_CONSTRUCT_OBJECT:
			{
				wcontext->set_constructing(true);
				break;
			}

		case OP_PREPARE_TO_EXPRESSION:
			{
				wcontext->set_in_expression(true);
				break;
			}

		case OP_CALL:
		case OP_CALL__WRITE:
			{
				Array *local_ops=static_cast<Array *>(i.next());
#ifdef DEBUG_EXECUTE
				debug_printf(pool(), " (%d)\n", local_ops->size());
				debug_dump(pool(), 1, *local_ops);

				debug_printf(pool(), "->\n");
#endif
				value=POP();

				// info: 
				//	code compiled so that this one's always method-junction, 
				//	not a code-junction
				Junction *junction=value->get_junction();
				if(!junction)
					throw Exception("parser.runtime",
						last_get_element_name, 
						"(%s) not a method or junction, can not call it",
							value->type());

				VMethodFrame frame(pool(), *last_get_element_name, *junction);
				if(local_ops){ // store param code goes here
					PUSH(&frame); // argument for *STORE_PARAM ops
					execute(*local_ops);
					POP();
				}
				frame.fill_unspecified_params();
				PUSH(self);  
				PUSH(root);  
				PUSH(rcontext);  
				PUSH(wcontext); 
				
				VStateless_class *called_class=frame.junction.self.get_class();
				if(wcontext->get_constructing()) {
					wcontext->set_constructing(false);
					if(frame.junction.method->call_type!=Method::CT_STATIC) {
						// this is a constructor call

						if(Value *value=called_class->create_new_value(pool())) {
							// some stateless_class creatable derivates
							self=value;
						} else 
							throw Exception("parser.runtime",
								&frame.name(),
								"is not a constructor, system class '%s' can be constructed only implicitly", 
								called_class->name().cstr());

						frame.write(*self, 
							String::UL_CLEAN  // not used, always an object, not string
						);
					} else
						throw Exception("parser.runtime",
							&frame.name(),
							"method is static and can not be used as constructor");
				} else {
					// this is not constructor call

					// not ^name.method call, name:method call; and
					// is context object or class & is it my class or my parent's class and?
					VStateless_class *read_class=rcontext->get_class();
					if(
						!(wcontext->get_somebody_entered_some_object() &&
						!wcontext->get_somebody_entered_some_class()) && 
						read_class && read_class->is_or_derived_from(*called_class)) // yes
						self=rcontext; // dynamic call
					else // no, not me or relative of mine (=total stranger)
						self=&frame.junction.self; // static call
				}

				frame.set_self(*self);

				// see OP_PREPARE_TO_EXPRESSION
				frame.set_in_expression(wcontext->get_in_expression());
				
				rcontext=wcontext=&frame;
				{
					const Method& method=*frame.junction.method;
					Method::Call_type call_type=
						called_class==self ? Method::CT_STATIC : Method::CT_DYNAMIC;
					if(
						method.call_type==Method::CT_ANY ||
						method.call_type==call_type) { // allowed call type?
						try {
							if(method.native_code) { // native code?
								// root unchanged, so that ^for ^foreach & co may write to locals
								method.check_actual_numbered_params(
									frame.junction.self, 
									frame.name(), frame.numbered_params());
								method.native_code(
									*this, 
									frame.name(), frame.numbered_params()); // execute it
							} else { // parser code
								root=&frame;
								// execute it
								recoursion_checked_execute(&frame.name(), *method.parser_code);
							}
						} catch(...) {
							// record it to stack trace
							exception_trace.push((void *)&frame.name());
							/*re*/throw;
						}
					} else
						throw Exception("parser.runtime",
							&frame.name(),
							"is not allowed to be called %s", 
								call_type==Method::CT_STATIC?"statically":"dynamically");

				}
				StringOrValue result=wcontext->result();

				wcontext=static_cast<WContext *>(POP());  
				rcontext=POP();  
				root=POP();  
				self=static_cast<Value *>(POP());

#ifdef DEBUG_STRING_APPENDS_VS_EXPANDS
				if(const String *s=value->get_string())
					wcontext_result_size+=s->used_rows()*sizeof(String::Chunk::Row);
#endif

				if(op.code==OP_CALL__WRITE) {
					write_assign_lang(result, last_get_element_name);
					// forget the fact they've entered some ^object.method[].
					// see OP_GET_ELEMENT
					wcontext->set_somebody_entered_some_object(false);
				} else { // OP_CALL
					PUSH(&result.as_value());
				}
				
#ifdef DEBUG_EXECUTE
				debug_printf(pool(), "<-returned");
#endif
				break;
			}

		// expression ops: unary
		case OP_NEG:
			{
				Value *operand=POP();
				value=NEW VDouble(pool(), -operand->as_double());
				PUSH(value);
				break;
			}
		case OP_INV:
			{
				Value *operand=POP();
				value=NEW VDouble(pool(), ~operand->as_int());
				PUSH(value);
				break;
			}
		case OP_NOT:
			{
				Value *operand=POP();
				value=NEW VBool(pool(), !operand->as_bool());
				PUSH(value);
				break;
			}
		case OP_DEF:
			{
				Value *operand=POP();
				value=NEW VBool(pool(), operand->is_defined());
				PUSH(value);
				break;
			}
		case OP_IN:
			{
				/// @test String::cmp
				Value *operand=POP();
				const char *path=operand->as_string().cstr();
				value=NEW VBool(pool(), 
					info.uri && strncmp(path, info.uri, strlen(path))==0);
				PUSH(value);
				break;
			}
		case OP_FEXISTS:
			{
				Value *operand=POP();
				value=NEW VBool(pool(), 
					file_readable(absolute(operand->as_string())));
				PUSH(value);
				break;
			}
		case OP_DEXISTS:
			{
				Value *operand=POP();
				value=NEW VBool(pool(), 
					dir_readable(absolute(operand->as_string())));
				PUSH(value);
				break;
			}

		// expression ops: binary
		case OP_SUB: 
			{
				b=POP();  a=POP();
				value=NEW VDouble(pool(), a->as_double() - b->as_double());
				PUSH(value);
				break;
			}
		case OP_ADD: 
			{
				b=POP();  a=POP();
				value=NEW VDouble(pool(), a->as_double() + b->as_double());
				PUSH(value);
				break;
			}
		case OP_MUL: 
			{
				b=POP();  a=POP();
				value=NEW VDouble(pool(), a->as_double() * b->as_double());
				PUSH(value);
				break;
			}
		case OP_DIV: 
			{
				b=POP();  a=POP();

				double a_double=a->as_double();
				double b_double=b->as_double();

				if(b_double == 0) {
					const String *problem_source=&b->as_string();
					throw Exception("number.zerodivision",
						problem_source,
						"Division by zero");
				}

				value=NEW VDouble(pool(), a_double / b_double);
				PUSH(value);
				break;
			}
		case OP_MOD: 
			{
				b=POP();  a=POP();

				double a_double=a->as_double();
				double b_double=b->as_double();

				if(b_double == 0) {
					const String *problem_source=&b->as_string();
					throw Exception("number.zerodivision",
						problem_source,
						"Modulus by zero");
				}

				value=NEW VDouble(pool(), fmod(a_double, b_double));
				PUSH(value);
				break;
			}
		case OP_INTDIV:
			{
				b=POP();  a=POP();

				int a_int=a->as_int();
				int b_int=b->as_int();

				if(b_int == 0) {
					const String *problem_source=&b->as_string();
					throw Exception("number.zerodivision",
						problem_source,
						"Division by zero");
				}

				value=NEW VInt(pool(), a_int / b_int);
				PUSH(value);
				break;
			}
		case OP_BIN_AND:
			{
				b=POP();  a=POP();
				value=NEW VDouble(pool(), 
					a->as_int() &
					b->as_int());
				PUSH(value);
				break;
			}
		case OP_BIN_OR:
			{
				b=POP();  a=POP();
				value=NEW VDouble(pool(), 
					a->as_int() |
					b->as_int());
				PUSH(value);
				break;
			}
		case OP_BIN_XOR:
			{
				b=POP();  a=POP();
				value=NEW VDouble(pool(), 
					a->as_int() ^
					b->as_int());
				PUSH(value);
				break;
			}
		case OP_LOG_AND:
			{
				b_code=POP_CODE();  a=POP();
				bool result;
				if(a->as_bool()) {
					execute(*b_code);
					b=POP();
					result=b->as_bool();
				} else
					result=false;
				value=NEW VBool(pool(), result);
				PUSH(value);
				break;
			}
		case OP_LOG_OR:
			{
				b_code=POP_CODE();  a=POP();
				bool result;
				if(a->as_bool()) 
					result=true;
				else {
					execute(*b_code);
					b=POP();
					result=b->as_bool();
				}
				value=NEW VBool(pool(), result);
				PUSH(value);
				break;
			}
		case OP_LOG_XOR:
			{
				b=POP();  a=POP();
				value=NEW VBool(pool(), a->as_bool() ^ b->as_bool());
				PUSH(value);
				break;
			}
		case OP_NUM_LT: 
			{
				b=POP();  a=POP();
				value=NEW VBool(pool(), a->as_double() < b->as_double());
				PUSH(value);
				break;
			}
		case OP_NUM_GT: 
			{
				b=POP();  a=POP();
				value=NEW VBool(pool(), a->as_double() > b->as_double());
				PUSH(value);
				break;
			}
		case OP_NUM_LE: 
			{
				b=POP();  a=POP();
				value=NEW VBool(pool(), a->as_double() <= b->as_double());
				PUSH(value);
				break;
			}
		case OP_NUM_GE: 
			{
				b=POP();  a=POP();
				value=NEW VBool(pool(), a->as_double() >= b->as_double());
				PUSH(value);
				break;
			}
		case OP_NUM_EQ: 
			{
				b=POP();  a=POP();
				value=NEW VBool(pool(), a->as_double() == b->as_double());
				PUSH(value);
				break;
			}
		case OP_NUM_NE: 
			{
				b=POP();  a=POP();
				value=NEW VBool(pool(), a->as_double() != b->as_double());
				PUSH(value);
				break;
			}
		case OP_STR_LT: 
			{
				b=POP();  a=POP();
				value=NEW VBool(pool(), a->as_string() < b->as_string());
				PUSH(value);
				break;
			}
		case OP_STR_GT: 
			{
				b=POP();  a=POP();
				value=NEW VBool(pool(), a->as_string() > b->as_string());
				PUSH(value);
				break;
			}
		case OP_STR_LE: 
			{
				b=POP();  a=POP();
				value=NEW VBool(pool(), a->as_string() <= b->as_string());
				PUSH(value);
				break;
			}
		case OP_STR_GE: 
			{
				b=POP();  a=POP();
				value=NEW VBool(pool(), a->as_string() >= b->as_string());
				PUSH(value);
				break;
			}
		case OP_STR_EQ: 
			{
				b=POP();  a=POP();
				value=NEW VBool(pool(), a->as_string() == b->as_string());
				PUSH(value);
				break;
			}
		case OP_STR_NE: 
			{
				b=POP();  a=POP();
				value=NEW VBool(pool(), a->as_string() != b->as_string());
				PUSH(value);
				break;
			}
		case OP_IS:
			{
				b=POP();  a=POP();
				value=NEW VBool(pool(), a->as(b->as_string().cstr())!=0);
				PUSH(value);
				break;
			}

		default:
			throw Exception(0,
				0,
				"invalid opcode %d", op.code); 
		}
	}
}

/// @test cache|prepare junctions 
Value *Request::get_element(const String *& remember_name, bool can_call_operator) {
	const String& name=POP_NAME();  remember_name=&name;
	Value *ncontext=POP();
	Value *value=0;
	if(can_call_operator)
		if(Method* method=OP.get_method(name)) { // looking operator of that name FIRST
			// as if that method were in self and we have normal dynamic method here
			Junction& junction=*NEW Junction(pool(), 
				*root, self->get_class(), method, 0,0,0,0);
			value=NEW VJunction(junction);
		}
	if(!value)
		value=ncontext->get_element(name);
	if(value)
		value=&process_to_value(*value); // process possible code-junction
	else
		value=NEW VVoid(pool());

	return value;
}

/**	@param intercept_string
	- true:
		they want result=string value, 
		possible object result goes to wcontext
	- false:
		they want any result[string|object]
		nothing goes to wcontext.
		used in @c (expression) params evaluation

    using the fact it's either string_ or value_ result requested to speed up checkes
*/
StringOrValue Request::process(Value& input_value, bool intercept_string) {
	StringOrValue result;
	Junction *junction=input_value.get_junction();
	if(junction && junction->code) { // is it a code-junction?
		// process it
#ifdef DEBUG_EXECUTE
		debug_printf(pool(), "ja->\n");
#endif

		if(!junction->root)
			throw Exception("parser.runtime",
				0,
				"junction used outside of context");

		PUSH(self);  
		PUSH(root);  
		PUSH(rcontext);  
		PUSH(wcontext);
		
		self=&junction->self;
		root=junction->root;
		rcontext=junction->rcontext;

		// for expression method params
		// wcontext is set 0
		// using the fact in decision "which wwrapper to use"
		bool using_code_frame=intercept_string && junction->wcontext;
		if(using_code_frame) {
			// almost plain wwrapper about junction wcontext, 
			// BUT intercepts string writes
			VCodeFrame local(pool(), *junction->wcontext);  
			wcontext=&local;

			// execute it
			recoursion_checked_execute(0/*result_name*/, *junction->code);
			
			// CodeFrame soul:
			//   string writes were intercepted
			//   returning them as the result of getting code-junction
			result.set_string(*wcontext->get_string());
		} else {
			// plain wwrapper
			WWrapper local(pool(), 0/*empty*/);
			wcontext=&local;
		
			// execute it
			recoursion_checked_execute(0/*result_name*/, *junction->code);
		
			result=wcontext->result();
		}
		
		wcontext=static_cast<WContext *>(POP());  
		rcontext=POP();  
		root=POP();  
		self=static_cast<Value *>(POP());
		
#ifdef DEBUG_EXECUTE
		debug_printf(pool(), "<-ja returned");
#endif
	} else {
		result.set_value(input_value);
	}
	return result;
}

const String& Request::execute_method(VMethodFrame& amethodFrame, const Method& method) {
	PUSH(self);  
	PUSH(root);  
	PUSH(rcontext);  
	PUSH(wcontext);
	
	// initialize contexts
	root=rcontext=self=&amethodFrame;
	wcontext=&amethodFrame;
	
	// execute!	
	execute(*method.parser_code);
	
	// result
	const String& result=wcontext->result().as_string();
	
	wcontext=static_cast<WContext *>(POP());  
	rcontext=POP();  
	root=POP();  
	self=static_cast<Value *>(POP());
	
	// return
	return result;
}

void Request::execute_method(Value& aself, 
							 const Method& method, VString *optional_param,
							 const String **return_string) {
	PUSH(self);  
	PUSH(root);  
	PUSH(rcontext);  
	PUSH(wcontext);
	
	// initialize contexts
	//root=rcontext=self=&aself;
	self=&aself;	
//	WWrapper local(pool(), &aself);
//	wcontext=&local; 
	Junction local_junction(pool(), *self, self->get_class(), &method, 0,0,0,0);
	VMethodFrame local_frame(pool(), method.name, local_junction);
	if(optional_param && local_frame.can_store_param()) {
		local_frame.store_param(optional_param);
		local_frame.fill_unspecified_params();
	}
	local_frame.set_self(*self);
	root=rcontext=wcontext=&local_frame; 

	// prevent non-string writes for better error reporting
	if(return_string)
		wcontext->write(local_frame);
	
	// execute!	
	execute(*method.parser_code);
	
	// result
	const String *result=0;
	if(return_string)
		*return_string=&wcontext->result().as_string();
	
	wcontext=static_cast<WContext *>(POP());  
	rcontext=POP();  
	root=POP();  
	self=static_cast<Value *>(POP());
}

void Request::execute_nonvirtual_method(VStateless_class& aclass, 
												 const String& method_name, VString *optional_param,
												 const String **return_string,
												 const Method **return_method) {

	const Method *method=aclass.get_method(method_name);
	if(return_string)
		*return_string=0;
	if(return_method)
		*return_method=method;

	if(method)
		execute_method(aclass, *method, optional_param, return_string);
}

const String *Request::execute_virtual_method(Value& aself, 
											  const String& method_name) {
	if(Value *value=aself.get_element(method_name))
		if(Junction *junction=value->get_junction())
			if(const Method *method=junction->method) {
				const String *result;
				execute_method(aself, *method, 0/*no params*/, &result);
				return result;
			}
			
	return 0;
}

