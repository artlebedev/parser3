/**	@page String String

¬ пам€ти строки[String] хран€тс€ в виде списка фрагментов[String::Chunk::Row .item], 
каждый помнит €зык, на котором написан фрагмент.
‘рагменты, полученные из скриптов считаютс€ чистыми(String::Untaint_lang ::UL_CLEAN),
а от пользовател€ - из environment, из form, с диска[table:load] или из sql сервера[table:sql] 
считаютс€ испачканными(String::Untaint_lang ::UL_TAINTED), 
при операци€х со строкой еЄ могут расдел€ть на части, но получающиес€ части по-прежнему помн€т свой €зык.
—троку могут записать в Request.wcontext, задав ей €зык. 
ѕри этом €зык задаЄтс€ всем еЄ испачканным част€м, они станов€тс€ не неопределЄнно гр€зными[UL_TAINTED], 
а "гр€зными, но известно, что нужно с ними сделать, чтобы стали чистыми, т.е. известен их €зык".
скажем
@verbatim
^table:sql{insert into news (title) values ('$form:title')]
@endverbatim
при обработке параметра посредством Temp_lang выставл€етс€ "текущий €зык"[Request::flang],
и при записи[Request::write_assign_lang] UL_TAINTED строки из $form:title фрагмента параметра
метода sql, наход€щегос€ в кавычках, получает €зык UL_SQL.

String можно преобразовать в обычную —-строку, использу€ String::cstr().
ѕри этом будут учтены €зыки фрагментов и произведены соответствующие вычищени€.
“акже можно воспользоватьс€ String::cstr(String::Untaint_lang), при этом будет все фрагменты строки
насильно будути считатьс€ написаннами на этом €зыке. Ѕезотносительно к указанному во фрагменте €зыку.
“акое используетс€, например, дл€ работы с именами файлов:
@verbatim
^table:load[$form:file_name]
@endverbatim
здесь при обычной обработке $form:file_name вышел бы UL_USER_HTML, а нужен UL_FILE_NAME,
при этом глупо всЄ врем€ подобное делать, как дл€ table:sql, настаива€ на {} параметрах.

ќбычным €зыком вывода €вл€етс€ String::Untaint_lang::UL_USER_HTML, 
исключение составл€ет CGI скрипт, который запускают вне веб-сервера,
в этом случае используетс€ €зык UL_AS_IS.

*/