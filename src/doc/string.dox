/**	@page String String

В памяти строки[String] хранятся в виде списка фрагментов[String::Chunk::Row .item], 
каждый помнит язык, на котором написан фрагмент.
Фрагменты, полученные из скриптов считаются чистыми(String::Untaint_lang ::UL_CLEAN),
а от пользователя - из environment, из form, с диска[table:load] или из sql сервера[table:sql] 
считаются испачканными(String::Untaint_lang ::UL_TAINTED), 
при операциях со строкой её могут расделять на части, но получающиеся части по-прежнему помнят свой язык.
Строку могут записать в Request.wcontext, задав ей язык. 
При этом язык задаётся всем её испачканным частям, они становятся не неопределённо грязными[UL_TAINTED], 
а "грязными, но известно, что нужно с ними сделать, чтобы стали чистыми, т.е. известен их язык".
скажем
@verbatim
^table:sql{insert into news (title) values ('$form:title')]
@endverbatim
при обработке параметра посредством Temp_lang выставляется "текущий язык"[Request::flang],
и при записи[Request::write_assign_lang] UL_TAINTED строки из $form:title фрагмента параметра
метода sql, находящегося в кавычках, получает язык UL_SQL.

String можно преобразовать в обычную С-строку, используя String::cstr().
При этом будут учтены языки фрагментов и произведены соответствующие вычищения.
Также можно воспользоваться String::cstr(String::Untaint_lang), при этом будет все фрагменты строки
насильно будути считаться написаннами на этом языке. Безотносительно к указанному во фрагменте языку.
Такое используется, например, для работы с именами файлов:
@verbatim
^table:load[$form:file_name]
@endverbatim
здесь при обычной обработке $form:file_name вышел бы UL_USER_HTML, а нужен UL_FILE_NAME,
при этом глупо всё время подобное делать, как для table:sql, настаивая на {} параметрах.

Обычным языком вывода является String::Untaint_lang::UL_USER_HTML, 
исключение составляет CGI скрипт, который запускают вне веб-сервера,
в этом случае используется язык UL_AS_IS.

*/