operators
    ^eval(expression)[format] expressions, apart from the usual functions, supports:
        #comments allowed
            they work until the end of the line or the closing parenthesis
            nested parentheses are allowed inside comments
        among the non-obvious operators:
            | bitwise XOR
            || logical XOR
            ~ bitwise negation
            \ integer division 10\3=3
        def checks if defined:
            an empty string is not defined
            an empty table is not defined
            an empty hash is not defined
        eq ne lt gt le ge for string comparison,
        in "/dir/" to check if the current document is located in the specified directory
            ["no expressions allowed inside; if you need a complex comparison, assign it to a variable"]
        is 'type' to check the type of the left operand,
            e.g., "is the method parameter not a hash?"
        -f checks if a file exists on disk,
        -d checks if a directory exists on disk,
        a quoted string (double or single quotes) is treated as a string, unquoted text is a string until the nearest whitespace
        numeric literals can be in hex format like 0xABC
        priorities:
            /* logical */
            %left "!||"
            %left "||"
            %left "&&"
            %left '<' '>' "<=" ">=" "lt" "gt" "le" "ge"
            %left "==" "!=" "eq" "ne"
            %left "is" "def" "in" "-f" "-d"
            %left '!'

            /* bitwise */
            %left '!|'
            %left '|'
            %left '&'
            %left '~'

            /* numerical */
            %left '-' '+'
            %left '*' '/' '%' '\\'
            %left '~'     /* negation: unary */

        literals:
            true
            false

    ^if(condition){then}{else}
    ^if(condition1){yes}[(condition2){yes}[(condition3){yes}[...]]]{no}
        unlimited number of additional conditions (elseif)

    ^switch[value]{^case[var1[;var2...]]{action}^case[DEFAULT]{default action}}

    ^while(condition){body}[[delimiter]|{delimiter executed before each non-empty non-first body}]

    ^for[i](0;4){body}[[delimiter]|{delimiter executed before each non-empty non-first body}]

    ^try{
        ...
        ^throw[sql.connect[;vasya[;mistaken]]] // previously ^error[text]
        ^throw[
            $.type[sql.connect]
            $.source[vasya]
            $.comment[mistaken]
        ]
        ...
    }{
        ^if($exception.type eq "sql"){
            $exception.handled(1|true)  ^rem{flag that exception is handled}
            ....
        }
        ^switch[$exception.type]{
            ^case[sql;mail]{
                $exception.handled(1)
                code handling sql error
                $exception.type = sql.connect
                $exception.file $exception.lineno $exception.colno [if not disabled at compile time]
                $exception.source = vasya
                $exception.comment = mistaken
            }
            ^case[DEFAULT]{
                code handling another error
                ^throw[$exception] << re-throw // DON'T! It's default behaviour!
            }
        }
    }

    ^break[]
        breaks the loop
    ^break(true|false)
        breaks the loop if true

    ^continue[]
        breaks the current iteration of the loop
    ^continue(true|false)
        breaks the current iteration if true

    ^return[]
        stops method execution
    ^return[value]
        assigns $result the value and stops method execution

    ^untaint[[as-is|file-spec|uri|http-header|mail-header|sql|js|json|parser-code|regex|xml|html|optimized-[as-is|xml|html]]]{code}
        default as-is

    ^taint[[lang]][code]
        default "just tainted, language unknown"

    ^apply-taint[[lang;]text]
        applies transformations specified in the string, "indefinitely dirty" is considered as lang, producing a clean string

    ^process[[$caller.CLASS|$object|$CLASS:CLASS]]{string to be processed as code}[
        $.main[what to rename @main to]
        $.file[name of the file supposedly containing this text]
        $.lineno(line number in the file from where this text originated, can be negative)
    ]
    ^process..[path][what to rename @main to]
        by default, methods are compiled into $self [in case of operator, $self=$MAIN:CLASS]

    ^connect[protocol://connection-string]]{code with ^sql[...] calls}
        mysql://user:pass@{host[:port][, host[:port]]|[/unix/socket]}/database?
            ClientCharset=parser-charset << charset in which parser thinks client works
            charset=UTF-8&
            timeout=3&
            compress=0&
            named_pipe=1&
            multi_statements=1&  allow executing more than one query in a single :sql{} request
            config_file=.my.cnf&
            config_group=parser3&  use group name from .my.cnf
            autocommit=1
            if autocommit is set to 0, it will perform commit/rollback

        pgsql://user:pass@{host[:port]|[local]}/database?
            client_encoding=win,[to-find-out]
            &datestyle=ISO,SQL,Postgres,European,NonEuropean=US,German,DEFAULT=ISO
            &ClientCharset=parser-charset << charset in which parser thinks client works

        odbc://DSN=dsn^;UID=user^;PWD=password^;ClientCharset=parser-charset
            ClientCharset << charset in which parser thinks client works

        sqlite://DBfile?
            ClientCharset=parser-charset& << charset in which parser thinks client works
            autocommit=1

        to use ^connect, the $SQL table must be defined beforehand (recommended in the system configuration auto.p)
#sql drivers
$SQL[
    $.drivers[^table::create{protocol	driver	client
mysql	$prefix/libparser3mysql.so	libmysqlclient.so
pgsql	$prefix/libparser3pgsql.so	libpq.so
sqlite	$prefix/libparser3sqlite.so	sqlite3.so
odbc	parser3odbc.dll
}]
]
    ^rem{}
        a comment, removed at compile time

    ^cache[file](seconds){code}[{catch code}]
        relative time assignment
        caches the string resulting from the code execution for 'seconds' seconds
        if 0 seconds, do not cache, and remove any existing old cache
        in the catch code, $exception.handled[cache]  ^rem{flag that exception is handled}
    ^cache[file][expires date]{code}[{catch code}]
        absolute time assignment
    ^cache[file]
        deletes the file [no error if it doesn't exist]
    ^cache(seconds)
    ^cache[expires date]
        signals to the upper-level ^cache "reduce it to these many 'seconds'/'expires'"
        ultimately: ^cache(0) cancels caching
    ^cache[]
        returns the current expires date

    each method has a local variable $result. If you put something in it,
    that will be the method's result, not its body

    each method has a local variable $caller, containing the parent stack frame,
    you can write to its local variables

    use(^use or @USE) searches for and includes a file:
        1. If the path starts with /, it is considered a path from the web root
        2. Relative to the current directory
        3. Relative to strings from the $MAIN:CLASS_PATH table, bottom-up
           $MAIN:CLASS_PATH is a global string or table with a path or paths to a directory
           with classes (from the web root), set it in the configuration auto.p

    A global table $CHARSETS[$.name[filename]]
       defines which characters are considered what (whitespace, letter, etc.), as well as their Unicode
    format: tab-delimited file, with a header:
        char    white-space    digit    hex-digit    letter    word    lowercase    unicode1    unicode2
        A       x              x        x            a        0x0041  0xFF21
        where char and lowercase can be letters or 0xCODES
        if the character has a single Unicode representation equal to itself, you can omit unicode
    UTF-8 is always available and is the default encoding for request and response
    WARNING: the encoding name is case-insensitive

syntax
    $name[new value]
    $name(arithmetic expression of new value)
    $name{code of new value}
    $name whitespace or ${name}something - variable value
    ^name parameters - call
    $name.CLASS - class of the value
    $name.CLASS_NAME - name of the class
    $name[$.key[] () {}] - constructor of a hash variable with element $name.key
    ^method[$.key[] () {}] - constructor of a hash parameter with element $parameter.key
    $CLASS.name  access a class variable

    the name ends before: space tab linefeed ; ] } ) " < > + * / % & | = ! ' , ?
        i.e. you can do $name,aaaa
        but if you need a character after the name, say -, then ${name}-

    in expressions, + and - are additional name boundaries

    you can access compound objects as: $name.subname where subname can be:
        a string
        a $variable
        a string$variable
        [code computing a string]
    for example: $hash[$.age(88)] $get[$.field[age]] ^hash.[$get.field].format{%05d}

parameters := one or more parameters
parameter :=
    (arithmetic expression) evaluated multiple times inside the call,
|   [code] evaluated once before the call,
|   {code} evaluated zero or many times inside the call,
    ';' are allowed, making multiple parameters in a single bracket


void
    all methods present in the string class object are available, the result behaves as if it were an empty string
    ^void:sql{query without result}{$.bind[see table::sql]}

int,double
    ^name.int[]
         integer value
    ^name.double[]
         double value
    ^name.bool[] ^name.bool(true|false)
         boolean value
    ^name.inc(how much +)
    ^name.dec(how much -)
    ^name.mul(how much *)
    ^name.div(how much /)
    ^name.mod(how much %)
    ^name.format[format]
    ^int/double:sql{query}[[$.limit(2) $.offset(4) $.default{0} $.bind[see table::sql]]]
        the query result should be one column/one row

string
    in expression
        def value means "not empty?"
        logical/numerical value equals an attempt to convert to double,
            an empty string quietly converts to 0
        example:
        ^if(def $form:name) not empty?
        ^if($user.isAlive) true? [auto-convert to number, not zero?]
    ^string:sql{query}[[$.limit(1) $.offset(4) $.default{n/a} $.bind[see table::sql]]]
        the query result should be one column/one row
    ^string.int[] ^string.int(default)
        integer value of the string, if conversion fails, default is taken
    ^string.double[] ^string.double(default)
        double value of the string, if conversion fails, default is taken
    ^string.bool[] ^string.bool(default)
        boolean value of the string, if conversion fails, default is taken
    ^string.format[format] %d  %.2f %02d...
    ^string.match[string-pattern|regex-pattern][[search options]] $prematch $match $postmatch $1 $2...
        search options:
        i CASELESS
        x whitespace in regex ignored
        s singleline = $ matches end of entire text
        m multiline = $ matches end of line[\n], not end of entire text
        g find all occurrences, not just one
        ' create columns prematch, match, postmatch
        n return the number of matches instead of a table
        U invert the meaning of the '?' modifier
    ^string.match[string-pattern|regex-pattern][search options]{replacement}
        additional search option:
        g replace all occurrences, not just one
    ^string.split[delimiter|regex][[lrhva]][[column name for vertical splitting]]
        l left to right [default]
        r right to left
        h nameless table with keys 0, 1, 2, ...
        v table of one column 'piece' or as provided [default]
        a array
    ^string.{l|r}split[delimiter] a table from the $piece column
        kept for compatibility
    ^string.upper|lower[]
    ^string.length[]
    ^string.mid(P[;N])
        without N - "until the end of the string"
    ^string.left(N), -1 returns the entire string
    ^string.right(N)
    ^string.pos[substring]
    ^string.pos[substring](position from which to search)
        <0 = not found
    ^string.replace[$table_of_substitutions_string_to_string]
    ^string.replace[$what;$to]
    ^string.save[[append;]path]
    ^string.save[path[;$.charset[in which encoding save] $.append(true)]]
        saves the string to a file
    ^string.trim[start|both|end|left|right[;chars]]
        removes chars from the start/end/or both start and end
        default 'chars' = whitespace chars
    ^string.trim[chars]
        removes chars from start and end
    ^string.base64[ $.pad(bool) $.wrap(bool) $.url-safe(bool) ] encode
    ^string:base64[encoded[; $.pad(bool) $.strict(bool) $.url-safe(bool) ]] decode
    ^string.idna[]
        IDNA encoding, supports Cyrillic domains
    ^string:idna[encoded]
        IDNA decoding, supports Cyrillic domains
    ^string.js-escape[]
        encoding for passing to JS (%uXXXX)
    ^string:js-unescape[escaped]
        decoding from js
    ^string:unescape[js|uri;escaped; $.charset[] ]
        decoding passed from js or uri
    ^string.contains[key]
        for compatibility with hashtable

table
    in expression
        logical value means "not empty?"
        numerical value equals count[]
    $table.field
    $table.field[new value]
    $table.fields
        from a named table returns the current record as a Hash
    ^table::create[[nameless]]{data}[[$.separator[^#09] $.encloser[]]]
    ^table::create[table][[$.limit(1) $.offset(5) $.offset[cur] $.reverse(1)]]
        clones the table
        reverse - in reverse order
    ^table::load[[nameless;]path[;options]]
        if not nameless, column names are taken from the first line
        empty lines, and lines in the first column containing '#' are ignored
        $.separator[^#09]
        $.encloser["] by default, none
    ^table::sql{query}[[$.limit(2) $.offset(4) $.bind[hash]]]
        bind associates variables in the query with their values
        currently implemented only for oracle
        in the query you need to write ":name"
        in the bind parameter pass a hash from which the value is taken (or where it is written)
    ^table.save[[nameless|append;]path[;options, see load]]
        saves the table to a file
    ^table.menu{body}[[delimiter]]
        executes the body code for each row of the table
    ^table.foreach[position;value]{body}[[delimiter]]
    ^table.line[]
        current table row, starting from 1
    ^table.offset[]
        offset of the current row from the start, starting from 0
    ^table.offset[[whence]](5)
        shifts whence=cur|set, without whence = cur
    ^table.count[], ^table.count[rows]
        number of rows in the table
    ^table.count[columns]
        number of columns
    ^table.count[cells]
        number of cells in the current row
    ^table.sort{{string-key-maker}|(numeric-key-maker)}[{desc|asc}] default=asc
    ^table.append{data}
    ^table.append[ $.column_name[column_value] ]
    ^table.insert{data} add a record at the current position
    ^table.insert[ $.column_name[column_value] ]
    ^table.delete[]
        deletes the record at the current position
    ^table.join[table][$.limit(1) $.offset(5) $.offset[cur]]
        adds records from the table, tables must have the same structure
    ^table.flip[]
        returns the transposed version
    ^table.locate[field;value][[$.limit(1) $.offset(5) $.offset[cur] $.reverse(1)]]
        moves the current row if found. returns bool
    ^table.locate(logical expression)[[$.limit(1) $.offset(5) $.offset[cur] $.reverse(1)]]
        moves the current row if found. returns bool
    ^table.hash{[field]|{code}|(expression)}[[value field(s)|table of value fields]{value code}][[$.distinct(1) $.distinct[tables] $.type[hash]]]
        by default $hash.key value is a hash where value fields are keys
        value fields may not be specified, then they are all columns including the key
        if distinct is true, no error if duplicate keys
        if distinct is tables, a hash of tables is created, containing rows with that key
        $.type[string/table] changes the element value to a string (specify one column) or a table
    ^table.columns[[column name]]
        table of one column 'column' or as provided
    ^table.cells[], ^table.cells(limit)
        returns an array of cells of the current row
    ^table.array[]
        returns an array of hashes, each hash representing the data of one row
    ^table.array[column]
        returns an array of values from the specified column
    ^table.array{code}
        returns an array of results from executing the given code for each row
    ^table.rename[column name;new column name] ^table.rename[ $.column_name[new column name] ...]
        renames a column or multiple columns
    $selected[^table.select(expression)]
        a table from those columns and rows where the condition matched
        $adults[^man.select($man.age>=18)]
    ^table.color[color1;color2]
        alternates color1 and color2 for each row

hash
    in expression
        logical value means "not empty?", a hash with _default is already not empty
        numerical value equals count[]
    $hash.key
        _default - a special key, if defined,
        then when accessing a non-existing key, _default value is returned
    $hash.fields
        returns $hash, making hash class more similar to table class
    ^hash::create[[|copy_from_hash|copy_from_hashfile]]
        creates a new hash, a copy of the old one
    ^hash.add[term]
        overwrites entries with the same name
    ^hash.sub[subtracted]
    ^hash.union[b]
        union, same-named remain
    ^hash.intersection[b][[$.order[self|arg]]]
        intersection, new hash, order defines the element order (as in the source hash or parameter hash)
    ^hash.intersects[b] = bool
    ^hash::sql{query}[[$.distinct(1) $.limit(2) $.offset(4) $.type[hash|string|table]]]
        results is hash(keys = values of the first column of the response) of hash(keys = names of the other columns), or
        string = each element's value is a string (need exactly two columns), or
        table = each element's value is a table
    ^hash.keys[[name of key column]]
        a table of one 'key' column or as provided
    ^hash.count[]
    ^hash.foreach[key;value]{body}[[delimiter]|{delimiter executed before each non-empty non-first body}]
    ^hash.delete[key]
        delete key
    ^hash.contain[key]
        checks if hash contains a key (bool)
    ^hash.at[first|last][[key|value|hash]]
    ^hash.at([-]N)[[key|value|hash]]
        access specified elements of an ordered hash
    ^hash.set[first|last;value]
    ^hash.set([-+]N)[value]
        sets the value of the specified ordered hash element
    ^hash.rename[old_key;new_key]
    ^hash.rename[ $.old_key[new_key] ...]
        renames the specified hash keys
    ^hash.sort[key;value]{{string-key-maker}|(numeric-key-maker)}[[desc|asc]] default=asc
    $reversed_hash[^hash.reverse[]]
    $selected[^hash.select[key;value](expression)[ $.limit(N) $.reverse(bool) $.default(bool) ]]
        a hash of keys and values for which the condition is true

hashfile
    ^hashfile::open[filename]
    ^hashfile.clear[]
        forget all
    $hashfile.key[value]
        put value
    $hashfile.key[$.value[value] $.expires[VALUE]]
        put value until expires
        expires can be a date, or number of days (0days=forever)
    $hashfile.key retrieve
    ^hashfile.delete[key] delete key
    ^hashfile.delete[] delete files containing data
    ^hashfile.hash[]
        convert to a regular hash
        removing expired pairs along the way
    ^hashfile.foreach[key;value]{body}[[delimiter]|{delimiter executed before each non-empty non-first body}]
    ^hashfile.release[]
        write data and release locks.
        next access to elements will reopen automatically.
    ^hashfile.cleanup[]
        iterate all elements and delete expired ones.

    example:
    $sessions[^hashfile::open[/db/sessions]]
    $sid[^math:uuid[]]
    $sessions.$sid[$.value[$uid] $.expires(1)]
    $uid[$sessions.$sid]

array
    in expression
        logical value means "not empty?"
        numerical value equals count[]
    $array.index, $array.(expression)
        returns the value at the given index
    $array.index[value], $array.(expression)[value]
        assigns a value by index
    $array[value;value;...]
        creates an array with the given values
    ^array::create[]
    ^array::create[value;value;...]
        creates an array with the given values or an empty array
    ^array::copy[array or hash with numeric keys]
        copies an array or a hash with numeric keys
    ^array.add[array or hash with numeric keys]
        adds elements from another array or hash, overwriting values for matching indexes
    ^array.join[array or any hash]
        appends elements from another array or hash to the end of the array
    ^array.append[value;value;...]
        appends elements to the end of the array
    ^array.insert(index)[value;value;...]
        inserts elements at the specified position in the array
    ^array.left(n)
        returns a new array of the first n elements
    ^array.right(n)
        returns a new array of the last n elements
    ^array.mid(m;n)
        returns a new array containing n initialized elements starting from position m
    ^array.delete(index)
        deletes an array element, leaving an empty spot
    ^array.remove(index)
        deletes an element and shifts subsequent elements to fill the gap
    ^array.push[value]
        adds an element to the end of the array
    ^array.pop[]
        returns the last element and removes it from the array
    ^array.contain(index)
        checks if an element exists at the given index (bool)
    ^array::sql{query}[ $.sparse(false|true) $.distinct(false|true) $.limit(n) $.offset(n) $.type[hash|string|table] ]
        creates an array based on a database query
        $.sparse(false), default - create a normal array. Row values from the query are added sequentially
        $.sparse(true) - create a sparse array. The first column must contain indexes
        at which values will be placed (similar to ^hash::sql{})
        result is an array of hash (keys=column names of the rest of the answer) or
        string = each element's value is a string (need exactly two columns), or
        table = each element's value is a table
    ^array.keys[[column name for keys]]
        a table of one 'key' column (or as provided) with the indexes of initialized elements
    ^array.count[]
        the number of initialized elements in the array
    ^array.count[all]
        the total number of elements, including uninitialized ones
    ^array.foreach[index;value]{code}[[delimiter]|{delimiter executed before each non-empty non-first body}]
        iterates over all initialized elements
    ^array.for[index;value]{code}[[delimiter]|{delimiter executed before each non-empty non-first body}]
        iterates over all elements
    ^array.at[first|last][[key|value|hash]]
    ^array.at([-]number)[[key|value|hash]]
        accesses an array element by its ordinal number
    ^array.set[first|last][value]
    ^array.set([-]number)[value]
        sets the value of an array element by ordinal number
    ^array.compact[]
        removes uninitialized elements
    ^array.compact[undef]
        removes uninitialized and empty elements
    ^array.sort[key;value]{{string-key-maker}|(numeric-key-maker)}[[desc|asc]] default=asc
        sorts the array
    $reversed_array[^array.reverse[]]
        returns a new array with elements in reverse order
    $selected[^array.select[key;value](expression)[ $.limit(N) $.reverse(bool) ]]
        selects array elements for which the condition is true

date
    date type can be used in expressions, substituting the number of days since epoch [1 January 1970 (UTC)], fractional
    the string value is in local time, numerically in UTC, range from 0000-00-00 00:00:00 to 9999-12-31 23:59:59
    by default the OS-defined timezone is used

    ^date::now[]
    ^date::now(days offset)
        returns now+offset
    ^date::today[]
        date at 00:00:00 of the current day
    ^date::today(integer days offset)
        date at 00:00:00 of current day+offset
    ^date::create(days since epoch)
    ^date::create(year;month[;day[;hour[;minute[;second[;TZ]]]]])
    ^date::create[date in format %Y-%m-%d %H:%M:%S]
        convenient creation from a value from a database
        format1: %Y[-%m[-%d[ %H[:%M[:%S]]]]]
        format2: %H:%M[:%S]
    ^date::create[date in format %Y-%m-%dT%H:%M[:%S]TZ]
        for creation from ISO 8601 format
        TZ format: Z(UTC) or +-hour[:minute] (offset from UTC)
    ^date::unix-timestamp()
    ^date.unix-timestamp[]
    $date.year month day hour minute second weekday yearday(0...) daylightsaving TZ weekyear
        TZ="" << local zone
    $date.year month day hour minute second can be set to new values, others are read-only
    ^date.double[] ^date.int[]
        the number of days since epoch [1 January 1970 (UTC)], fractional or truncated
    ^date.roll[year|month|day](+-offset)
        shifts the date
    ^date.roll[TZ;New zone]
        says that the date is in such a timezone: affects .hour & Co
    ^date:roll[TZ;New zone]
        says that by default all dates are in that timezone
    ^date.sql-string[[datetime|date|time]]
        datetime or without parameter - %Y-%m-%d %H:%M:%S
        date                          - %Y-%m-%d
        time                          - %H:%M:%S
        where published='^date.sql-string[]'
    ^date:calendar[rus|eng](year;month)
        returns an unnamed table, columns: 0..6, week, year
    ^date:calendar[rus|eng](year;month;day)
        returns a named table, columns: year, month, day, weekday
    ^date:last-day(year;month)
        returns the last day of the month
    ^date.last-day[]
        returns the last day of $date's month
    ^date.gmt-string[]
        Fri, 23 Mar 2001 09:32:23 GMT
    ^date.iso-string[]
        2001-03-23T12:32:23+03

file
    $uploaded_file_from_post.name
    $uploaded_file_from_post.size
    $uploaded_file_from_post.text
    ^file.save[text|binary;filename[;$.charset[which charset to save in]]]
    ^file:delete[filename]
    ^file:find[filename][{if not found}]
    ^file:list[path[;pattern-string|pattern-regex]]
        table with columns name dir
    ^file:list[path;$.filter[pattern-string|pattern-regex] $.stat(true)]
        table with columns name dir size [mca]date
    ^file::load[text|binary;big.zip[;domain_press_release_2001_03_01.zip][;options]]
    ^file::create[text|binary;filename;data]
    ^file::create[text|binary;filename;data[;$.charset[charset of the created file] $.content-type[...]]]
    ^file::create[string-or-file-content[;$.name[name] $.mode[text|binary] $.content-type[...] $.charset[...]]]
    $loaded_file.size
    $loaded_or_created_file.mode = text/binary
    ^file::stat[filename]
    $stated_or_loaded_file.size .adate .mdate .cdate
    ^file::cgi[[text|binary;]filename[;env hash +options[;1cmd[;2line[;3ar[;4g[;5s]]]]]]]
        any argument can be string or array of strings
        the returned header is split into $fields
        $status
        $stderr
    ^file::exec[[text|binary;]filename[;env hash[;1cmd[;2line[;3ar[;4g[;5s;...under unix max 50 args]]]]]]]
        any argument can be string or array of strings
        options:
            $.stdin[text|file] if empty, disables automatic passing of HTTP-POST data
    ^file:move[oldfilename;newfilename]
        can rename and move directories [win32: but not across disk boundaries]
        directories for dest are created with 775 permissions
        source directory is removed if empty after move
    ^file:copy[filename;copy_filename[; $.append(1) ]]
        can only copy files
    ^file:lock[filename]{code}
        the file is created if necessary
        locked
        code executed
        unlocked
    ^file:dirname[/a/some.tar.gz|file]=/a (works like *nix command)
    ^file:dirname[/a/b/|file]=/a (works like *nix command)
    ^file:basename[/a/some.tar.gz|file]=some.tar.gz (like *nix)
    ^file:basename[/a/b/|file]=b (like *nix)
    ^file:justname[/a/some.tar.gz|file]=some.tar
    ^file:justext[/a/some.tar.gz|file]=gz
    /some/page.html: ^file:fullpath[a.gif] => /some/a.gif
    ^file.sql-string[]
        inside ^connect gives a correctly escaped string that can be used in queries
    ^file::sql{query}[[ $.name[filename_for_download] $.content-type[user content-type] ]]
        the query result should be "one row".
        columns:
        first column - data
        if second exists - filename
        if third - content-type
    ^file.base64[ $.pad(bool) $.wrap(bool) $.url-safe(bool) ]
        encode
    ^file:base64[filename[; $.pad(bool) $.wrap(bool) $.url-safe(bool) ]]
        encode
    ^file::base64[encoded string[; $.pad(bool) $.strict(bool) $.url-safe(bool) ]]
        decode
    ^file::base64[mode;filename;encoded string[; $.content-type[...] $.pad(bool) $.strict(bool) $.url-safe(bool) ]]
        decode
    ^file:crc32[filename]
        calculates crc32 of the specified file
    ^file.crc32[]
        calculates crc32 of the object
    ^file.md5[], ^file:md5[filename]
        returns the file's digest, 16 bytes as a string,
        bytes in hex, contiguous, lowercase

image
    $image[^image::measure[DATA[; $.exif(bool) $.xmp(bool) $.xmp-charset[] $.video(bool) ]]]
        checks the file extension case-insensitively
        can measure gif, jpg, tiff, bmp, webp and mp4 (mov)
    $image.exif << hash after measure jpeg with exif information and $.exif(true)
        $image.exif.DateTime & co
            [full list see https://exiftool.org/TagNames/EXIF.html]
        numbers as int/double,
        dates as date,
        enumerations as hash with keys 0..count-1
    $image.src .width .height
    $image.line-width  number=line width
    $image.line-style  string=line style '*** * '='*** * *** * *** * '
    ^image.html[[hash]]
        <img ...>
    ^image::load[background.gif]
        only gif so far
    ^image::create(width X;height Y[;background color default white]])
    ^image.line(x0;y0;x1;y1;0xffFFff)
    ^image.fill(x;y;0xffFFff)
    ^image.rectangle(x0;y0;x1;y1;0xffFFff)
    ^image.bar(x0;y0;x1;y1;0xffFFff)
    ^image.replace(hex-color1;hex-color2)[table x:y polygon_vertices]
    ^image.polyline(color)[table x:y points]
    ^image.polygon(color)[table x:y polygon_vertices]
    ^image.polybar(color)[table x;y polygon_vertices]
    ^image.font[set_of_letters;font_file.gif][(space_width[;char_width])]
        the character height = image height/number of letters in the set
        if char_width is specified, then monospaced, if 0, char_width = gif width
    ^image.font[set_of_letters;font_file.gif;
        $.space(space_width)      // default = gif width
        $.width(char_width)       // see above, default proportional
        $.spacing(letter_spacing) // default = 1
    ]
    ^image.text(x;y)[text] AS_IS
    ^image.length[text] AS_IS
    ^image.gif[optional filename]
        encodes to FILE with content-type=image/gif the filename will be used by $response:download
    ^image.arc(center x;center y;width;height;start in degrees;end in degrees;color)
    ^image.sector(center x;center y;width;height;start in degrees;end in degrees;color)
    ^image.circle(center x;center y;r;color)
    ^image.copy[source](src x;src y;src w;src h;dst x;dst y[;dest w[;dest h[;tolerance]]])
        if dest_w/dest_h are specified, resizes the piece
            when reducing size, does resample
            only suitable for simplifying low-color graphics like charts/pie,
            not suitable for thumbnails
        if dest_h is not specified, aspect ratio is kept
        tolerance - a number [square distance in RGB space to the target color],
            defining how greedy the color approximation from the palette is [default=150]
            smaller - more accurate but colors run out quickly
            larger - less accurate approximation, but covers a bigger part
    ^image.pixel(x;y)[(color)]
        get or set pixel color

regex
    in expression
        logical value is always true
        numerical value is equal to the number of bytes of the compiled pattern
    ^regex::create[pattern-string|regex][[search options]]
    ^pattern.size[]
        number of bytes of the compiled pattern
        if the value is very large - it is worth consulting pcre documentation and possibly rewriting the pattern
    ^pattern.study_size[]
        size of the study-structure. if == 0 - the pattern cannot be "studied"
    $pattern.pattern
        the text of the pattern
    $pattern.options
        the string with the original text of the options

console
    $console:timeout
    $console:line
        read/write string

cookie
    $cookie:name read old or newly set cookie
    $cookie:name[value] for 90 days
    $cookie:name[$.value[value] $.expires[VALUE] $.secure(true) $.domain[domain name] $.httponly(true)]
        the expires field value can be 'session', a date, or a number of days (0days=forever)
        if it's a date, it will be converted to "Sun, 25-Aug-2002 12:03:45 GMT"
    $cookie:fields
        hash with all cookies

env
    $env:variable
    $env:fields hash with environment variables
    $env:PARSER_VERSION parser version

form
    [the first element with the same name is taken from GET, then from POST]
    $form:field
        string/file
    $form:nameless
        field with a value from a nameless parameter "?value&...", "...&value&...", "...&value"
    $form:qtail
        string with the value after the second "?xxxxx" if there was no ',' [imap]
    $form:fields
        hash with all form fields
    $form:elements.field
        array with all values of the field - both string and file
    $form:tables.field
        table with one column "field" containing the values for multiple entries
    $form:files.field
        hash with file-type field values, keys - 0, 1, ..., value - file
    $form:imap
        a hash with keys 'x' and 'y' with ?1,2 suffixes when using server-side image map

inet
    ^inet:ntoa(long)
    ^inet:aton[IP]
    ^inet:name2ip[name][[ $.ipv[4|6|any] $.table(true) ]]
        direct conversion of a name to an IP address
    ^inet:ip2name[ip][ $.ipv[4|6|any] ]
        reverse conversion from IP address to name
    ^inet:hostname[]
        host name

json
    ^json:parse[-json-string-[;
        $.depth(maximum depth, default == 19)
        $.double(false)              disable built-in parsing of floating-point numbers (enabled by default)
                                     in this case they will appear in the resulting object as strings
        $.int(false)                 disable built-in parsing of integers (enabled by default)
                                     in this case they will appear in the resulting object as strings
        $.distinct[first|last|all]   how duplicate keys in objects are handled
                                     first - keep the first encountered element
                                     last  - keep the last encountered element
                                     all   - keep all elements. starting from the 2nd,
                                              they get numeric suffixes (key_2 etc)
                                     by default duplicate keys cause an exception
        $.object[method-junction]    user method[key;object], called for all parsed
                                     objects and object keys; method returns a new object
        $.array[method-junction]     user method called for arrays
        $.taint[taint language]      sets the transformation language for all result strings
    ]]
        parses a json-string into a hash

    ^json:string[system or user object[;
        $.skip-unknown(false)    disable exception and output 'null' when serializing objects of types
                                 other than void, bool, string, int, double, date, table, hash, and file
        $.indent(true)           format the resulting string with indentation according to nesting depth
        $.date[sql-string|gmt-string|iso-string|unix-timestamp]
                                 date output format, default = sql-string
        $.table[object|array|compact]
                                 format for tables, default=object
                                 object: [{"c1":"v11","c2":"v12",...},{"c1":"v21","c2":"v22",...},...]
                                 array:  [["c1","c2",...] || null (for nameless),["v11","v12",...],...]
                                 compact: ["v11" || ["v11","v12",...],...]
        $.file[text|base64|stat] output file content in the specified mode (by default file content
                                 is not included in output)
        $.xdoc[hash]             parameters for converting xdoc to string (as in ^xdoc.string[])
        $.type[method-junction]  any type can be output using a user method
                                 that must take 3 parameters: key, object of that type, and options
                                 of the ^json:string[] call
        $._default[method]       user method, called to output all user-class objects.
                                 The method must take 3 parameters: key, object, and call options.
        $._default[method name]  method name of a user method, if present it will be called for serialization
        $.void[null|string]      undefined value will be output as null (default)
                                 or as an empty string
    ]]
        serializes a system or user object into a json-string

mail
    $mail.received=MESSAGE:
        .from
        .reply-to
        .subject
        .date of class date
        .message-id
        .raw[
            .RAW_USER_HEADER_FIELD
        ]
        $.{text|html|file#}[ << numbered as in mail:send (text, text2, ...) (file, file2, ...)
            $.content-type[
                $.value[{text|...|x-unknown}/{plain|html|...|x-unknown}]
                [$.charset[windows-1251]] << in which it arrived, now already transcoded
                $.USER_DEFINED_HEADER_FIELD
            ]
            $.description
            $.content-id
            $.content-md5
            $.content-location
            .raw[
                .RAW_USER_HEADER_FIELD
            ]
            $.value[string|FILE]
        ]
        $.message#[MESSAGE] (message, message2, ...)

    ^mail:send[
        $.options[-odd]
            unix: a string that will be added to the sendmail startup command
                -odd means "quickly put in the queue without email checking"
            win32: ignored
        $.charset[the encoding of the headers and text blocks]
        $.any-header-field
        $.text[string]
        $.text[
            $.any-header-field
            $.value[string]
        ]
        $.html{string}
        $.html[
            $.any-header-field
            $.value{string}
        ]
        $.file#[FILE]
        $.file#[
            $.any-header-field
            $value[FILE]
        ]
    ]
    if charset is specified, the email is transcoded to this charset
    content-type.charset does not affect transcoding
    after the part name a # number can follow

    ^mail:send[
#       by default, matches the source encoding.
#       sets the body encoding
        $.charset[windows-1251]
#       no default
        $.content-type[$.value[text/plain] $.charset[windows-1251]]
        $.from["vasya" <vasya@design.ru>]
        $.to["petya" <petya@design.ru>]
        $.subject[subject]
        $.body[
            text
        ]
    ]

    ^mail:send[$.header-field[] $.charset[mail encoding] $.body[if body is not a string, but a hash, a multipart email is sent]]
        if charset is specified, the email is transcoded to that charset
        content-type.charset does not affect transcoding
        after the part name, an integer can follow, parts go in numerical order.
        if body is a string, then it's just the email text, no attachments.
        if body is a hash, then these are parts, text blocks first, then attachments
        this is the old format, supported for backward compatibility
        if the part name begins with "text", it's a text block.
        if the part name begins with "file", it's an attachment, format:
            $file[$.format[uue|base64] $.value[DATA] $.name[user-file-name]]
        important: for multipart do not specify content-type

        ^mail:send[
#           by default, matches the source encoding
#           sets the body encoding
            $.charset[windows-1251]
#           no default
            $.content-type[$.value[text/plain] $.charset[windows-1251]]
            $.from["vasya" <vasya@design.ru>]
            $.to["petya" <petya@design.ru>]
            $.subject[subject]
            $.body[
                text
            ]
        ]

        ^mail:send[
            $.from["vasya" <vasya@design.ru>]
            $.to["petya" <petya@design.ru>]
            $.subject[subject]
            $.body[
                $.text[
#                   sets the body encoding
                    $.charset[windows-1251]
#                   no default
                    $.content-type[$.value[text/plain] $.charset[windows-1251]]
                    $.body[words]
                ]
#               for convenience you can specify only one part, then it won't be multipart
                $.file[
                    $.value[^file::load[my beloved.doc]]
                    $.name[my beloved.doc]
                    $.format[base64]
                ]
                $.file2[
                    $.value[^file::load[my beloved.doc]]
                    $.name[my beloved.doc]
                ]
            ]
        ]
    under unix, the program with arguments is used, set by
        $MAIL.sendmail[command]
    if not specified, checks if /usr/sbin/sendmail or
    /usr/lib/sendmail is available and if so, runs with "-t".

    under Windows, SMTP protocol is used, server is set by
        $MAIL.SMTP[smtp.domain.ru]

math
    $math:PI
    ^math:round floor ceiling
    ^math:trunc frac
    ^math:abs sign
    ^math:exp log log10
    ^math:sin asin cos acos tan atan atan2
    ^math:degrees radians
    ^math:pow sqrt
    ^math:random(range_width)
    ^math:convert[number|file](base-from;base-to)[[ $.format[string|file] ]]
    ^math:convert[number|file][alphabet](base-to)[[ $.format[string|file] ]]
    ^math:convert[number|file](base-from)[alphabet][[ $.format[string|file] ]]
        converts a string or file with a number from one numeral system to another
        the numeral system can be set by an alphabet, a number from 2 to 16 (equivalent to the alphabet 0123456789ABCDEF), or 256 (all ASCII characters)
    ^math:uuid[ $.lower(bool) $.solid(bool) ]
        22C0983C-E26E-4169-BD07-77ECE9405BA5
        win32: uses cryptapi
        unix: uses /dev/urandom,
            if not present, /dev/random,
            if not, rand
    ^math:uuid7[ $.lower(bool) $.solid(bool) ]
        0193CBF0-7898-7000-A391-AC513CC15658
        https://www.rfc-editor.org/rfc/rfc9562.html#name-uuid-version-7
    ^math:uid64[ $.lower(bool) ]
        BA39BAB6340BE370
    ^math:md5[string]
        returns the digest of the string, 16 bytes as a string,
        bytes in hex, contiguous, lowercase
    ^math:crypt[password;salt]
        salt prefix $apr1$ triggers built-in MD5 algorithm,
        if salt body is empty, it is generated randomly
        $1$ calls the OS 'crypt' MD5 algorithm if supported.
        for other salts see OS 'crypt' documentation.
    ^math:crc32[string]
        calculates crc32 of the string
    ^math:sha1[string]
    ^math:digest[[md5|sha1|sha256|sha512];string or file][[ $.format[hex|base64|file] $.hmac[key string|key file] ]]
        combines the ability to use various cryptographic hashing algorithms.
        $.hmac[key] for verifying the integrity of transmitted data

memory
    ^memory:compact[]
        collect garbage, freeing space for new data (warning: process memory is never released)
        useful before XSL transform
    ^memory:auto-compact(frequency)
        sets automatic garbage collection frequency, from 0 (off) up to 5 (max)

reflection
    ^reflection:create[class;constructor[;pa[;ra[;ms]]]]
        calls the specified class constructor (no more than 100 parameters)
    ^reflection:create[ $.class[name] $.constructor[name] $.arguments[ $.1[pa] $.2[ra] $.3[ms] ] ]
        calls the specified class constructor
    ^reflection:classes[]
        a hash of all classes. key = class name, value can be methoded (a class with methods) or void
    ^reflection:class[object]
        the class of the given object
    ^reflection:class_name[object]
        the class name of the given object
    ^reflection:base[object]
        the parent class of the given object
    ^reflection:base_name[object]
        the parent class name of the given object
    ^reflection:class_by_name[class name]
        obtains the class by name
    ^reflection:class_alias[class name;new class name]
        sets an alias for the specified class
    ^reflection:def[class;class name]
        checks if the class exists
    ^reflection:methods[class]
        a hash with a list of methods of the specified class, values are strings 'native' or 'parser'
    ^reflection:method[class or object;method name]
        returns the junction-method of the class or object
    ^reflection:filename[object or class or method]
        returns the filename where the object, class or method is defined
    ^reflection:fields[class or object]
        a hash with the list of static fields of the specified class or dynamic fields of the specified object
    ^reflection:fields_reference[object]
        an editable hash of the dynamic fields of the specified object
    ^reflection:field[class or object;field name]
        returns the value of the specified field of the class or object. getters are ignored.
    ^reflection:copy[source;destination]
        copies fields from one object or class to another
    ^reflection:uid[class or object]
        returns the identifier of the object or class
    ^reflection:method_info[class;method]
        a hash with parameters of the specified class method
        $.inherited[class] name of the class where the method was defined (returned only if the method was defined in an ancestor)
        $.overridden[class] name of the class where the method was defined (returned only if the method was defined in an ancestor)
        for native classes a hash is returned:
            .min_params(minimum required number of parameters)
            .max_params(maximum possible number of parameters)
            .call_type[dynamic|static|any]
        for parser classes a hash is returned:
            key is parameter number (0, 1, ...), value is parameter name
    ^reflection:dynamical[[object or class, caller if absent]]
        returns true if the method was called from a dynamic context when passing
        a parameter returns true if a dynamic object was passed, false if a class
    ^reflection:delete[class or object;variable name]
        deletes the variable with the specified name in the specified class or object
    ^reflection:is[element name;class name][[context]]
        analogous to the 'is' operator, allowing to determine if the element is code.
    ^reflection:tainting[[language|tainted|optimized];string]
        a string in which each character of the original string corresponds to a character with a transformation code
    ^reflection:stack[ $.args(false/true) $.locals(false/true) $.limit(n) $.offset(o)]
        the current state of the method call stack in the parser
    ^reflection:mixin[source; $.to[target] $.name[name] $.methods(true/false) $.fields(true/false) $.overwrite(false/true)]
        copies methods and fields from one class to another

request
    $request:query
    $request:uri
    $request:document-root
        directory relative to which paths are considered in parser, default = $env:DOCUMENT_ROOT
    $request:argv
        hash with command-line parameters. keys 0, 1, ... [0 - name of the processed file]
    $request:charset
        the source document encoding
        used in upper/lower and match[][i]
        WARNING: you must set $request/response:charset before using form class fields
    $request:method
        request method (GET|POST|PUT)
    $request:body
        POST-request body as text
    $request:body-file
        POST-request body as a file
    $request:body-charset
        POST-request encoding
    $request:headers
        hash with request headers (without HTTP_ prefix)

response
    $response:field[value] and can read old - $response:field
        the value can be string or hash:
            $value[abc] field: {abc}<<part
            $attribute[zzz] field: abc; {attribute=zzz}<<part
        field or attribute value can be string or date
            if date, it will be converted to "Sun, 25-Aug-2002 12:03:45 GMT"
    $response:headers
         accumulated fields
    $response:body[DATA]
        replaces the standard response
    $response:download[DATA]
        replaces the standard response, sets a flag causing the browser to suggest download
    $response:status
    ^response:clear[] forget all set response fields
    $response:charset
        client encoding, i.e.:
        1) from which $form: fields will be transcoded after retrieval from browser
        2) into which the document will be transcoded before sending to browser
        3) into which URI language text will be transcoded
        does not add anything to content-type; if needed, do it manually
        WARNING: you must set $request/response:charset before using form class fields

status
    $status:sql
        cache table
            url    time
            url    time
            url    time
    $status:stylesheet
        cache table
            file    time
            file    time
            file    time
    $status:rusage hash
        utime user time used
        stime system time used
        maxrss max resident set size
        ixrss integral shared text memory size
        idrss integral unshared data size
        isrss integral unshared stack size
        tv_sec
        tv_usec
           $s[$status:rusage]
           ^s.tv_sec.format[%.0f].^s.tv_usec.format[%06.0f]
    $status:memory hash
        used
            includes some pages that were allocated but never written
        free
        ever_allocated_since_compact
            return the number of bytes allocated since the last collection
        ever_allocated_since_start
            return the total number of bytes [EVER(c)PAF] allocated in this process,
            never decreases
    $status:pid
        process id
    $status:tid
        thread id
    $status:mode
        working mode, cgi|console|mail|httpd|apache|isapi
    $status:log-filename
        path to parser3.log error log

xdoc(xnode)
    $xdoc.search-namespaces hash, where keys=prefixes, values=urls

    DOM1 attributes:
    readonly attribute DocumentType doctype
    readonly attribute Element documentElement

    DOM1 methods:
    Element createElement(in DOMString tagName)
    DocumentFragment createDocumentFragment()
    Text createTextNode(in DOMString data)
    Comment createComment(in DOMString data)
    CDATASection createCDATASection(in DOMString data)
    ProcessingInstruction createProcessingInstruction(in DOMString target,in DOMString data)
    Attr createAttribute(in DOMString name)
    EntityReference createEntityReference(in DOMString name)
    NodeList getElementsByTagName(in DOMString tagname)

    DOM2 some methods:
    ^.getElementById[elementId] = xnode
        The DOM implementation must have information that says which attributes are of type ID.
        Attributes with the name "ID" are not of type ID unless so defined.
        Implementations that do not know whether attributes are of type ID or not
        are expected to return null.

    String encoding and default for $.encoding equals the current output page encoding, $response:charset

    ::sql{...}
    ::create[[URI]]{<?xml?><string/>} old name 'set'
    ::create[[URI]][qualifiedName]
        URI default = disk path to requested document
        for directories a trailing / is mandatory
    ::create[file] can be usable:
        $f[^file::load[binary;http://;some HTTP options here...]]
        $x[^xdoc::create[$f]]
    ::load[file.xml[;options]]
    .transform[rules.xsl|xdoc][[params hash]] returns dom
        the template is cached, cache is updated if the template file date changes,
        or the date of "template_name.stamp" changes [stamp date check has priority]
        <xsl:output
        method = "xml" | "html" | "text"
        version = nmtoken
        encoding = string
        omit-xml-declaration = "yes" | "no"
        standalone = "yes" | "no"
        cdata-section-elements = qnames
        indent = "yes" | "no"
        media-type = string />
        parameters are passed as is, not xpath expressions

    .string[[output options]]
    .save[file.xml[;output options]] with header
    .file[[output options]] = file
        output options are identical to xsl:output attributes
            [exception: cdata-section-elements ignored]
        returns media-type when substituting $response:body[here]

    if the document is referenced as:
        parser://method/param/to/that/method
        then ^MAIN:method[/param/to/that/method] is used as the document
        [note: the parameter always comes with a leading /, even if there were no parameters]

xnode
    DOM1 attributes:
    $node.nodeName
    $node.nodeValue
        read
        write
    $node.nodeType = int
        ELEMENT_NODE                   = 1
        ATTRIBUTE_NODE                 = 2
        TEXT_NODE                      = 3
        CDATA_SECTION_NODE             = 4
        ENTITY_REFERENCE_NODE          = 5
        ENTITY_NODE                    = 6
        PROCESSING_INSTRUCTION_NODE    = 7
        COMMENT_NODE                   = 8
        DOCUMENT_NODE                  = 9
        DOCUMENT_TYPE_NODE             = 10
        DOCUMENT_FRAGMENT_NODE         = 11
        NOTATION_NODE                  = 12
            $vasyaNode.type==$xnode:ELEMENT_NODE
    $node.parentNode
    $node.childNodes = array of nodes
    $node.firstChild
    $node.lastChild
    $node.previousSibling
    $node.nextSibling
    $node.ownerDocument = xdoc
    $node.prefix
    $node.namespaceURI
    $element_node.attributes = hash of xnodes
    $element_node.tagName
    $attribute_node.specified = boolean
        true if the attribute received its value explicitly in the XML document,
        or if a value was assigned programmatically with the setValue function.
        false if the attribute value came from the default value declared in the document's DTD.
    $attribute_node.name
    $attribute_node.value
    $text_node/cdata_node/comment_node.substringData
    $pi_node.target = target of this processing instruction
        XML defines this as the first token following the markup
        that begins the processing instruction.
    $pi_node.data = The content of this processing instruction
        From the first non-whitespace character after the target
        to the character immediately preceding the ?>.
    document_node.
        readonly attribute DocumentType doctype
        readonly attribute DOMImplementation implementation
        readonly attribute Element documentElement
    document_type_node.
        readonly attribute DOMString name
        readonly attribute NamedNodeMap entities
        readonly attribute NamedNodeMap notations
    notation_node.
        readonly attribute DOMString publicId
        readonly attribute DOMString systemId

    DOM1 node methods:
    Node insertBefore(in Node newChild,in Node refChild)
    Node replaceChild(in Node newChild,in Node oldChild)
    Node removeChild(in Node oldChild)
    Node appendChild(in Node newChild)
    boolean hasChildNodes()
    Node cloneNode(in boolean deep)

    DOM1 element methods:
    DOMString getAttribute(in DOMString name)
    void setAttribute(in DOMString name, in DOMString value) raises(DOMException)
    void removeAttribute(in DOMString name) raises(DOMException)
    Attr getAttributeNode(in DOMString name)
    Attr setAttributeNode(in Attr newAttr) raises(DOMException)
    Attr removeAttributeNode(in Attr oldAttr) raises(DOMException)
    NodeList getElementsByTagName(in DOMString name)
    void normalize()

    Introduced in DOM Level 2:
    Node importNode(in Node importedNode, in boolean deep) raises(DOMException)
    NodeList getElementsByTagNameNS(in DOMString namespaceURI, in DOMString localName)
    boolean hasAttributes()

    XPath:
    ^node.select[xpath/query/expression] = array of nodes,
        empty array if nothing found
    ^node.selectSingle[xpath/query/expression] = first node if any
    ^node.selectBool[xpath/query/expression] = bool if any or die
    ^node.selectNumber[xpath/query/expression] = double if any or die
    ^node.selectString[xpath/query/expression] = string if any or die

DATA::=string | file | hash
    hash of the form
    [
        $.file[filename on disk]
        $.name[filename for user]
        $.mdate[date]
    ]

MAIN
    this is the class automatically loaded from the configuration auto.p, a bunch of auto.p and the requested document:
        configuration auto.p
            cgi:
                1. either full path from environment variable CGI_PARSER_SITE_CONFIG or next to parser binary
            isapi: windows directory
            apache module:
                1) ParserConfig [can be in .htaccess]
        auto.p goes down from DOCUMENT_ROOT/ through the directory tree to the directory of the processed file, inclusive
    the class is assembled from all these files, subsequent ones become parents of the previous ones
    the name of the last loaded is MAIN, previous ones have no names

    after loading MAIN class, its @main[] is called
    the result is passed to its @postprocess[data] if($data is string) ...
    the result is then returned to the user

if an error occurs and try is not specified, it can be nicely reported to the user by defining
    @unhandled_exception[exception;stack]
        $exception.type  string "type of problem"
        $exception.file $exception.lineno $exception.colno file, line and position where the problem occurred [if not disabled at compile time]
        $exception.source line that caused the problem
        $exception.comment English comment
        stack table with columns file line name,
            in reverse order the names[name] and places[file line] of the operators/methods that caused the error.

when loading a file (file::load, table::load, xdoc::load) you can specify such a filename:
    http://domain/document[?params<<deprecated, use $.form[...]]
    and possibly specify options:
        $.method[GET|POST|HEAD]
        $.timeout(3)  << in seconds, default=2
        $.cookies[
            $.name[value]
        ]
        $.headers[
            $.field[value] << value format like $response:HEADER
        ]
        $.enctype[multipart/form-data]
        $.form[
            $.field1[string]
            $.field2[^table::create{one_column_only^#0Avalue1^#0Avalue2}]
            $.field3[file]
        ]
        $.body[string|file]
        default user-agent=parser3
        by default, getting http status != 200 >> creates http.status error, can be disabled by $.any-status(1)
        $.charset[default encoding of remote documents], if server returns content-type:charset - IT OVERRIDES
        $.response-charset[encoding of remote documents], not overridden by content-type:charset
        $.user[user]
        $.password[password]
    file::load writes additional fields
        FIELD:value (response field names in uppercase)
        tables << a hash of FIELD->table with a single column "value"
            in such tables you can get repeating headers, e.g. multiple set-cookies
            todo: make separate cookies

system error types:
    parser.compile       ^test[}                compilation (unmatched bracket, ...)
    parser.runtime       ^if(0).                parameters (more/less than needed, wrong types, ...)
    number.zerodivision  ^eval(1/0) ^eval(1%0)
    number.format        ^eval(abc*5)
    file.lock                                                        shared/exclusive lock error
    file.missing         ^file:delete[delme]                         not found
    file.access          ^table::load[.]                             no rights
    file.read            ^file::load[...]                            error while reading file
    file.seek                                                        seek failed
    file.execute         ^file::cgi[...]                             incorrect cgi header/can't execute
    image.format         ^image::measure[index.html]                 not gif/jpg
    sql.connect          ^connect[mysql://baduser:pass@host/db]{}    not found/timeout
    sql.execute          ^void:sql{select bad}                       syntax error
    sql.duplicate
    sql.access
    sql.missing
    xml                  ^xdoc::create{<forgot?>}                    any error in xml/xslt libs
    smtp.connect                                                     not found/timeout
    smtp.execute                                                     communication error
    email.format         hren tam@null.ru                            wrong email format (bad chars/empty)
    email.send           $MAIL.sendmail[/shit]                       sendmail not executable
    http.host            ^file::load[http://notfound/there]          host not found
    http.connect         ^file::load[http://not_accepting/there]     host found, but does not accept connections
    http.timeout         ^file::load[http://host/doc]                load operation failed to complete in # seconds
    http.response        ^file::load[http://ok/there]                host found, connection accepted, bad answer
    http.status          ^file::load[http://ok/there]                host found, connection accepted, status!=200
    date.range           ^date::create(10000;1;1)                    date out of valid range

if $SIGPIPE(1) is defined in MAIN, then if processing was interrupted by the user, a message
    about this is written to parser3.log

if the method description explicitly contains the local variable result (there is also an implicit variable),
    then the code for outputting whitespace literals does not get into the final bytecode

$Id: operators.txt,v 1.262 2024/12/20 18:59:22 moko Exp $
