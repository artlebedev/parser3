	!literal
		push literal
	!with_root
		push root
	!with_self
		push self
	!with_read
		push rcontext
	!with_write
		push wcontext
	!construct
		value=pop
		name=pop
		ncontext=pop
		ncontext.put_element(name, value)
    !write
    	value=pop
    	wcontext.write(value)
	!get_element
	    name=pop
		ncontext=pop
		value=ncontext.get_element(name) // name бывает method, тогда выдаёт new junction(self:method)
		name бывает junction, и если это code-junction, то авто-вычисляет
		push value
	!get_element_write
		optimized push/pop: get_element, write
    !create_ewpool
		push wcontext
		wcontext=new wcontext()
	!reduce_ewpool
		value=wcontext.value()
		wcontext=pop
		push value
    !create_rwpool
    	ncontext=pop
    	push rcontext
		rcontext=ncontext
		push wcontext
		wcontext=new wcontext(ncontext)
	!reduce_rwpool
		value=wcontext.get_string()
		wcontext=pop
		rcontext=pop
		push value
	!get_method_frame
	    name=pop  // это бывает junction, не name
		ncontext=stack[0]
		method=ncontext.get_method[self/class?;params;local;code/native_code](name)
		unless(method) method=operators.get_method[...;code/native_code](name)
        frame=new frame(0, method.params, method.locals);
		push frame
    !store_param
		value=pop
		frame=stack[0]
		frame.store(value)
	!call
		frame=pop
		ncontext=pop
		push root self rcontext wcontext 
		left_class=ncontext.get_class()
		right_class=frame.self.get_class()
		self=f(left_class[thoughts' food], right_self[junction], right_class[static], wcontext.value()[dynamic], new(right_class)[construct])
		frame.set_self(self)
		root=rcontext=wcontext=frame
		code=method.code
		execute code
		result=wcontext
		pop wcontext rcontext self root
		push(result)
	!
  	OP_NEG
  	OP_INV 
  	OP_NOT	
  	OP_DEF
  	OP_IN
  	OP_FEXISTS
  		stack[0]=@stack[0]
  	OP_SUB OP_ADD OP_MUL OP_DIV OP_MOD 
  	OP_BIN_AND OP_BIN_OR
  	OP_LOG_AND OP_LOG_OR
  	OP_NUM_LT OP_NUM_GT OP_NUM_LE OP_NUM_GE OP_NUM_EQ OP_NUM_NE
  	OP_STR_LT OP_STR_GT OP_STR_LE OP_STR_GE OP_STR_EQ OP_STR_NE
  	OP_XOR 
  		b=pop
  		a=pop
  		value=a @ b
  		push value
  	!create_swpool
		push wcontext
		wcontext=new wcontext()
  	!reduce_swpool
		value=wcontext.get_string()
		wcontext=pop
		push value

----------------------------------------------------------------------------------------------------------------------

    .	^process(^item[code])
    	специального ничего не надо, просто внутри запустится ещё раз compile+execute
        поставить проверку на бексконечную рекурсию: compile из execute
    
    !	${имя}
	
	!	длывоадфывлопфволрпычспрочалп
	>
		"длывоадфывлопфволрпычспрочалп"
		write

	!	$self.поле
	>
		with_self
		"поле"
		get_element
		write

	!	$:поле
	>
		with_root
		"поле"
		get_element
		write

	!	$человек{
			$возраст == $:человек.возраст
		}
	>
		with_read
		"человек"
		get_element
		create_rwpool
		code
		reduce_rwpool
		write


	!	$человек.$:поле
	!	$человек.$поле
	>
	    with_read
		"человек"
		get_element
		create_ewpool
		...write
		reduce_ewpool
		get_element_write

	!	$человек.возраст
	>
	    with_read
		"человек"
		get_element
		"возраст"
		get_element_write

	!	$человек.возраст(^eval[2*2])
	>
	    with_write
		"человек"
		get_element
		"возраст"
		create_ewpool
		...write
		reduce_ewpool
		construct
	
	!	$возраст(124)
	>
		with_write
		"возраст"
		"124"
		construct

	!	$человек.возраст(55)
	>
	    with_write
		"человек"
		get_element
		"возраст"
		"55"
		construct

	!	$:поле(123)
	>
		with_root
		"поле"
		123
		construct

	!	^метод{^eval[2*2]}
	>
	    with_read
		"метод"
		get_method_frame
		{code}
		create_junction
		store_param
		call
		write

	!	^метод(48)  [ громкое нет гадости: ^$метод(). пользуйтесь junctions, нефиг безобразия нарушать ]
	>
	    with_read
		"метод"
		get_method_frame
		"48"
		store_param
		call

	!	^^ ^$ ^; ^) ^} ^( ^{

	-	^ifdef(param1;param2)...
		
	
	?
		^something{^method()}
	?
		^something($method) .... ^method(param)
	?
		$a(=;1+2) == %d
		$a(%d;1+2)
		$a(+-*/;1+2)


	?
		@sum[a;b][result]
		if[;
			$result(^eval[a+b])
	    ;
	    	...
	    ]
        ^return($result)
	    
	    @main

	    -^sum[1;2]-

	-   $результат(=выражение)

	-	$строка.format(%6d)

	!	из instance: $CLASS
	!	в class: NAME,PARENTS,STATIC
        $CLASS.NAME = полосатая_таблица
        $CLASS.PARENTS = (таблица)
        $CLASS.STATICS = STATICS hash
        $CLASS.field = static.field
	!	в class: STATICS, это hash с этими static'ами
		
	?	$переменная(^имя_класса:имя_конструктора(параметр1;параметр2))
		with_write
		...параметры...
		new "имя_класса" "имя_конструктора" [leaves VObject on stack]
		construct

	?	$переменная(^имя_класса:имя_конструктора(параметр))
		with_write
        vclass("имя_класса")
        "имя_конструктора"
		get_class_method_frame
		"параметр"
		store_param
		call [leaves VObject on stack?]
		construct

	!	$переменная(^имя_класса:имя_конструктора(параметр))
	-
		with_write
		!
        vclass("имя_класса")  [вместо обычного with_read!]
        "имя_конструктора"
        get_element
		get_method_frame
		"параметр"
		store_param
		[methodframe is wcontext(vobject(vclass))] call [wcontext.write(value) // value == VObject]
		!
		construct

			VClass *context_class=awcontext.get_class();
            VClass *called_class=junction.self.get_class();
            // переменной уже назначен класс?
			if(context_class) { // да
				// это я или мой родитель? 
				if(context_class.is_or_derived_from(called_class)) // да
					self=junction.self; // dynamic call
				else // нет
					self=called_class; // static call
			} else { // нет -- constructor: $some(^class:method[..]) call
				self=new VObject(pool, called_class); // 'self' := new instance of 'class:'
				method_frame.write(self);
			}
			method_frame.set_self(self);

	!	$имя_класса:переменная
	-
		очевидно


	!	выражение
		$a+$b*$c
		^sin($a)	
		^test($a;$b)

	  0	
		- + * /	Арифметические выражения вычитания, сложения, умножения и деления соответственно
		%	Остаток от деления. Но -11%2=-1
		~	Битовая инверсия
		^	XOR
		& |	Битовые операции AND и OR соответственно
		&& ||	Логические операции AND и OR соответственно
		< > <= >= == !=	Знаки "меньше", "больше", "меньше или равно", "больше или равно", "равно", "не равно" соответственно.
		!	Логический NOT
		Round()	Операция округления.round(-1.23)=-1, round(-1.58)=-2, round(1.58)=2
		floor()	Операция округления в меньшую сторону.floor(1.23)=1, floor(-1.23)=-2
		ceiling()	Операция округления в большую сторону.ceiling(1.23)=2, ceiling(-1.23)=-1
		abs()	abs(1.23)=1.23, abs(-1.23)=1.23
		sign()	Знак выражения.sign(1.23)=1, sign(0)=0, sign(-1.23)=-1
	  +	
	    def для проверки defined,
		eq ne lt gt le ge для сравнения строк, 
		in /dir/ для проверки[раньше ^start],
		-f для проверки существования файла на диске,
		строка в кавычках - строка, без кавычек строка до 
			ближайшего whitespace
	>	
		literal (VString  or  VDouble)
		OP_NEG
		OP_SUB OP_ADD OP_MUL OP_DIV OP_MOD 
		OP_INV  
		OP_BIN_AND OP_BIN_OR
		OP_LOG_AND OP_LOG_OR
		OP_NUM_LT OP_NUM_GT OP_NUM_LE OP_NUM_GE OP_NUM_EQ OP_NUM_NE
		OP_STR_LT OP_STR_GT OP_STR_LE OP_STR_GE OP_STR_EQ OP_STR_NE
		OP_NOT	
		OP_DEF
		OP_IN
		OP_FEXISTS
		create_swpool
		для "... ..."" ..."
		reduce_swpool





